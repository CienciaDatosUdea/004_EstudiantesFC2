#include "../include/flow.h"
#include <cstdio>
#include <iostream>
#include <vector>
#include <fstream>
#include <stdexcept>

Grid::Grid(double x_min_, double x_max_,
           double y_min_, double y_max_, int nx_, int ny_)
    : x_min(x_min_), x_max(x_max_), y_min(y_min_), y_max(y_max_), nx(nx_), ny(ny_) {

    if (nx < 2 || ny < 2) throw std::invalid_argument("nx and ny must be >= 2");

    dx = (x_max - x_min) / (nx - 1);
    dy = (y_max - y_min) / (ny - 1);

    XY.resize(nx);
    for (int i = 0; i < nx; ++i) {
        XY[i].resize(ny, std::vector<double>(2));
    }

    for (int i = 0; i < nx; i++) {
        for (int j = 0; j < ny; j++) {
            XY[i][j][0] = x_min + i * dx;
            XY[i][j][1] = y_min + j * dy;
        }
    }
}

CampoVelocidadesPresion::CampoVelocidadesPresion(Grid &G_)
    : G(G_) {
    // we don't allocate here. CondicionesIniciales is responsible for initialisation
}

void CampoVelocidadesPresion::CondicionesIniciales(
    std::function<double(double,double)> u0,
    std::function<double(double,double)> v0,
    std::function<double(double,double)> p0)
{
    U.resize(G.nx, std::vector<double>(G.ny, 0.0));
    V.resize(G.nx, std::vector<double>(G.ny, 0.0));
    P.resize(G.nx, std::vector<double>(G.ny, 0.0));

    for (int i = 0; i < G.nx; ++i) {
        for (int j = 0; j < G.ny; ++j) {
            double x = G.XY[i][j][0];
            double y = G.XY[i][j][1];
            if (u0) U[i][j] = u0(x,y); else U[i][j] = 1e-10;
            if (v0) V[i][j] = v0(x,y); else V[i][j] = 1e-10;
            if (p0) P[i][j] = p0(x,y); else P[i][j] = 10.0;
        }
    }
}

void CampoVelocidadesPresion::BoundaryCondition() {
    // Inferior (j = 0)
    for (int i = 0; i < G.nx; i++) {
        U[i][0] = 0;
        V[i][0] = 0;
        // Neumann-like: copy neighbor
        P[i][0] = P[i][1];
    }
    // Izquierda (i = 0)
    for (int j = 0; j < G.ny; j++) {
        U[0][j] = 0;
        V[0][j] = 0;
        P[0][j] = P[1][j];
    }
    // Derecha (i = nx-1)
    for (int j = 0; j < G.ny; j++) {
        U[G.nx - 1][j] = 0;
        V[G.nx - 1][j] = 0;
        P[G.nx - 1][j] = P[G.nx - 2][j];
    }
    // Superior (j = ny-1) lid-driven cavity example
    for (int i = 0; i < G.nx; i++) {
        U[i][G.ny - 1] = 1; // lid
        V[i][G.ny - 1] = 0;
        P[i][G.ny - 1] = 0;
    }
}

ComputePresion::ComputePresion(CampoVelocidadesPresion &Campo_, double rho_, double dt_, int nit_)
    : Campo(Campo_), rho(rho_), dt(dt_), nit(nit_) {}

void ComputePresion::presionUpdate() {
    int nx = Campo.G.nx;
    int ny = Campo.G.ny;
    double dx = Campo.G.dx;
    double dy = Campo.G.dy;

    // Preallocate Pn
    std::vector<std::vector<double>> Pn(nx, std::vector<double>(ny, 0.0));

    for (int it = 0; it < nit; ++it) {
        // copy current pressure to Pn so we use previous iteration values
        Pn = Campo.P;

        for (int i = 1; i < nx - 1; ++i) {
            for (int j = 1; j < ny - 1; ++j) {
                // Gradientes para el tÃ©rmino fuente b
                double dudx = (Campo.U[i + 1][j] - Campo.U[i - 1][j]) / (2.0 * dx);
                double dudy = (Campo.U[i][j + 1] - Campo.U[i][j - 1]) / (2.0 * dy);
                double dvdx = (Campo.V[i + 1][j] - Campo.V[i - 1][j]) / (2.0 * dx);
                double dvdy = (Campo.V[i][j + 1] - Campo.V[i][j - 1]) / (2.0 * dy);
                double b = rho * (
                    (1.0 / dt) * (dudx + dvdy)
                    - dudx * dudx
                    - 2.0 * dudy * dvdx
                    - dvdy * dvdy
                );

                Campo.P[i][j] = (
                    (Pn[i + 1][j] + Pn[i - 1][j]) * (dy * dy) +
                    (Pn[i][j + 1] + Pn[i][j - 1]) * (dx * dx) -
                    b * (dx * dx) * (dy * dy)
                ) / (2.0 * (dx * dx + dy * dy));
            }
        }
        // apply boundary conditions for P after interior update
        Campo.BoundaryCondition();
    }
}

ComputeCampo::ComputeCampo(ComputePresion &omega_)
    : omega(omega_) {
    int nx = omega.Campo.G.nx;
    int ny = omega.Campo.G.ny;
    f.resize(nx, std::vector<double>(ny, 0.0));

    for (int i = 0; i < nx; ++i) {
        for (int j = 0; j < ny; ++j) {
            f[i][j] = 10.0; // example body force in x direction
        }
    }
}

void ComputeCampo::velocidadesUpdate() {
    int nx = omega.Campo.G.nx;
    int ny = omega.Campo.G.ny;
    double dx = omega.Campo.G.dx;
    double dy = omega.Campo.G.dy;
    double dt = omega.dt;
    double rho = omega.rho;
    double nu = 0.1;

    // Copias para tiempo n
    std::vector<std::vector<double>> Un = omega.Campo.U;
    std::vector<std::vector<double>> Vn = omega.Campo.V;

    for (int i = 1; i < nx - 1; i++) {
        for (int j = 1; j < ny - 1; j++) {
            // U component
            double advU = Un[i][j] * (Un[i][j] - Un[i - 1][j]) / dx
                        + Vn[i][j] * (Un[i][j] - Un[i][j - 1]) / dy;

            double lapU = (Un[i + 1][j] - 2 * Un[i][j] + Un[i - 1][j]) / (dx * dx)
                        + (Un[i][j + 1] - 2 * Un[i][j] + Un[i][j - 1]) / (dy * dy);

            double dpdx = (omega.Campo.P[i + 1][j] - omega.Campo.P[i - 1][j]) / (2.0 * dx);

            omega.Campo.U[i][j] = Un[i][j]
                - dt * advU
                - dt * (1.0 / rho) * dpdx
                + nu * dt * lapU
                + f[i][j] * dt;

            // V component
            double advV = Un[i][j] * (Vn[i][j] - Vn[i - 1][j]) / dx
                        + Vn[i][j] * (Vn[i][j] - Vn[i][j - 1]) / dy;

            double lapV = (Vn[i + 1][j] - 2 * Vn[i][j] + Vn[i - 1][j]) / (dx * dx)
                        + (Vn[i][j + 1] - 2 * Vn[i][j] + Vn[i][j - 1]) / (dy * dy);

            double dpdy = (omega.Campo.P[i][j + 1] - omega.Campo.P[i][j - 1]) / (2.0 * dy);

            omega.Campo.V[i][j] = Vn[i][j]
                - dt * advV
                - dt * (1.0 / rho) * dpdy
                + nu * dt * lapV;
        }
    }
    omega.Campo.BoundaryCondition();
}

FieldWriter::FieldWriter(const std::string &filename) {
    file.open(filename);
    if (!file.is_open())
        throw std::runtime_error("No se pudo abrir el archivo: " + filename);
}

void FieldWriter::writePosicionCampo(const Grid &G, const CampoVelocidadesPresion &Campo) {
    int nx = G.nx;
    int ny = G.ny;
    file << "# i\tj\tx\ty\tu\tv\tp\n";
    file << "# nx\tny\n";
    file << "# " << nx << "\t" << ny << "\n";
    file << "# ---------------------------\n";

    for (int i = 0; i < nx; ++i) {
        for (int j = 0; j < ny; ++j) {
            file << i << "\t"
                 << j << "\t"
                 << G.XY[i][j][0] << "\t"
                 << G.XY[i][j][1] << "\t"
                 << Campo.U[i][j] << "\t"
                 << Campo.V[i][j] << "\t"
                 << Campo.P[i][j] << "\n";
        }
    }
}
